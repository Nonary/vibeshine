<!DOCTYPE html>
<html lang="en" data-bs-theme="auto">

<head>
  <%- header %>
    <style>
      .config-page {
        padding: 1em;
        border: 1px solid #dee2e6;
        border-top: none;
      }

      .buttons {
        padding: 1em 0;
      }

      /* Sticky config header with save-status dot */
      .config-sticky-header {
        position: sticky;
        top: 0;
        z-index: 1020;
        /* above content, below navbar if fixed */
        background: var(--bs-body-bg);
        padding-top: .5rem;
        padding-bottom: .5rem;
      }

      .config-sticky-header .header-row {
        display: flex;
        justify-content: space-between;
        align-items: center;
      }

      .config-sticky-header h1 {
        margin-bottom: 0;
      }

      .status-area {
        display: flex;
        align-items: center;
        gap: .5rem;
      }

      .status-area.clickable {
        cursor: pointer;
      }

      .status-area.clickable .status-text {
        text-decoration: underline;
        text-underline-offset: 2px;
      }
  .status-actions { display:flex; align-items:center; gap:.5rem; }

      .save-status {
        display: inline-block;
        width: .75rem;
        height: .75rem;
        border-radius: 50%;
        vertical-align: middle;
      }

      .save-status.status-saving {
        background-color: #0d6efd;
        /* bootstrap primary */
        box-shadow: 0 0 0 .25rem rgba(13, 110, 253, .15);
        animation: pulse 1.2s ease-in-out infinite;
      }

      .save-status.status-applied {
        background-color: #198754;
        /* bootstrap success */
      }

      .save-status.status-deferred {
        background-color: #fd7e14;
        /* bootstrap orange */
      }

      .save-status.status-waiting {
        background-color: #6c757d;
        /* bootstrap secondary gray */
        opacity: .85;
      }

      @keyframes pulse {
        0% {
          transform: scale(1);
          opacity: 1;
        }

        50% {
          transform: scale(1.2);
          opacity: .75;
        }

        100% {
          transform: scale(1);
          opacity: 1;
        }
      }

      /* Temporary highlight for restart button when navigated */
      .pulse-highlight {
        animation: btnPulse 1.2s ease-in-out 3;
      }

      @keyframes btnPulse {
        0% {
          box-shadow: 0 0 0 0 rgba(253, 126, 20, .7);
        }

        70% {
          box-shadow: 0 0 0 .6rem rgba(253, 126, 20, 0);
        }

        100% {
          box-shadow: 0 0 0 0 rgba(253, 126, 20, 0);
        }
      }
    </style>
</head>

<body id="app" v-cloak>
  <Navbar></Navbar>
  <div class="container">
    <div class="config-sticky-header">
      <div class="header-row">
        <h1>{{ $t('config.configuration') }}</h1>
        <div class="status-actions">
          <div class="status-area" :class="{ clickable: restartRequired }" role="button" :aria-disabled="!restartRequired"
            tabindex="0" @click="onStatusClick" @keydown.enter.prevent="onStatusClick"
            @keydown.space.prevent="onStatusClick">
            <span class="save-status" :class="statusClass"></span>
            <span class="status-text">{{ statusText }}</span>
          </div>
          <button v-if="pendingRestartSave" class="btn btn-sm btn-primary" @click="manualSave">{{ $t('_common.save') }}</button>
        </div>
      </div>
    </div>
    <div class="my-3"></div>
    <div class="form" v-if="config">
      <!-- Header -->
      <ul class="nav nav-tabs">
        <li class="nav-item" v-for="tab in tabs" :key="tab.id">
          <a class="nav-link" :class="{'active': tab.id === currentTab}" href="#"
            @click="currentTab = tab.id">{{tab.name}}</a>
        </li>
      </ul>

      <!-- General Tab -->
      <general v-if="currentTab === 'general'" :config="config" :platform="platform">
      </general>

      <!-- Input Tab -->
      <inputs v-if="currentTab === 'input'" :config="config" :platform="platform">
      </inputs>

      <!-- Audio/Video Tab -->
      <audio-video v-if="currentTab === 'av'" :config="config" :platform="platform">
      </audio-video>

      <!-- Network Tab -->
      <network v-if="currentTab === 'network'" :config="config" :platform="platform">
      </network>

      <!-- Files Tab -->
      <files v-if="currentTab === 'files'" :config="config" :platform="platform">
      </files>

      <!-- Advanced Tab -->
      <advanced v-if="currentTab === 'advanced'" :config="config" :platform="platform">
      </advanced>

      <container-encoders :current-tab="currentTab" :config="config" :platform="platform">
      </container-encoders>
    </div>

    <!-- Bottom banners removed per new UX -->
    <div class="mb-3 buttons">
      <button id="restart-apply-button" class="btn btn-success" @click="apply" v-if="restartRequired && !restarted">{{
        $t('_common.apply') }}</button>
    </div>
  </div>
</body>


<script type="module">
  import { computed, createApp } from 'vue'
  import { initApp } from './init'
  import Navbar from './Navbar.vue'
  import General from './configs/tabs/General.vue'
  import Inputs from './configs/tabs/Inputs.vue'
  import Network from './configs/tabs/Network.vue'
  import Files from './configs/tabs/Files.vue'
  import Advanced from './configs/tabs/Advanced.vue'
  import AudioVideo from './configs/tabs/AudioVideo.vue'
  import ContainerEncoders from './configs/tabs/ContainerEncoders.vue'
  import { $tp, usePlatformI18n } from './platform-i18n'

  const app = createApp({
    components: {
      Navbar,
      General,
      Inputs,
      Network,
      Files,
      Advanced,
      // They will be accessible via audio-video, container-encoders only.
      AudioVideo,
      ContainerEncoders,
    },
    data() {
      return {
        platform: "",
        saved: false,
        restarted: false,
        saving: false,
        appliedNow: false,
        deferred: false,
        restartRequired: false,
        config: null,
        currentTab: "general",
        initialized: false,
        userChanged: false,
        _autoSaveTimer: null,
        _statusClearTimer: null,
        // Autosave gating for restart-required options
        restartGatedKeys: [
          'port', 'address_family', 'origin_web_ui_allowed',
          'capture', 'encoder', 'install_steam_audio_drivers'
        ],
        serverBaseline: {},
        restartGatedDirty: {},
        pendingRestartSave: false,
        tabs: [ // TODO: Move the options to each Component instead, encapsulate.
          {
            id: "general",
            name: "General",
            options: {
              "locale": "en",
              "sunshine_name": "",
              "min_log_level": 2,
              "global_prep_cmd": [],
              "notify_pre_releases": "disabled",
            },
          },
          {
            id: "input",
            name: "Input",
            options: {
              "controller": "enabled",
              "gamepad": "auto",
              "ds4_back_as_touchpad_click": "enabled",
              "motion_as_ds4": "enabled",
              "touchpad_as_ds4": "enabled",
              "back_button_timeout": -1,
              "keyboard": "enabled",
              "key_repeat_delay": 500,
              "key_repeat_frequency": 24.9,
              "always_send_scancodes": "enabled",
              "key_rightalt_to_key_win": "disabled",
              "mouse": "enabled",
              "high_resolution_scrolling": "enabled",
              "native_pen_touch": "enabled",
              "keybindings": "[0x10,0xA0,0x11,0xA2,0x12,0xA4]",  // todo: add this to UI
            },
          },
          {
            id: "av",
            name: "Audio/Video",
            options: {
              "audio_sink": "",
              "virtual_sink": "",
              "install_steam_audio_drivers": "enabled",
              "adapter_name": "",
              "output_name": "",
              "dd_configuration_option": "disabled",
              "dd_resolution_option": "auto",
              "dd_manual_resolution": "",
              "dd_refresh_rate_option": "auto",
              "dd_manual_refresh_rate": "",
              "dd_hdr_option": "auto",
              "dd_config_revert_delay": 3000,
              "dd_config_revert_on_disconnect": "disabled",
              "dd_mode_remapping": { "mixed": [], "resolution_only": [], "refresh_rate_only": [] },
              "dd_wa_hdr_toggle_delay": 0,
              "max_bitrate": 0,
              "minimum_fps_target": 0
            },
          },
          {
            id: "network",
            name: "Network",
            options: {
              "upnp": "disabled",
              "address_family": "ipv4",
              "port": 47989,
              "origin_web_ui_allowed": "lan",
              "external_ip": "",
              "lan_encryption_mode": 0,
              "wan_encryption_mode": 1,
              "ping_timeout": 10000,
            },
          },
          {
            id: "files",
            name: "Config Files",
            options: {
              "file_apps": "",
              "credentials_file": "",
              "log_path": "",
              "pkey": "",
              "cert": "",
              "file_state": "",
            },
          },
          {
            id: "advanced",
            name: "Advanced",
            options: {
              "fec_percentage": 20,
              "qp": 28,
              "min_threads": 2,
              "hevc_mode": 0,
              "av1_mode": 0,
              "capture": "",
              "encoder": "",
            },
          },
          {
            id: "nv",
            name: "NVIDIA NVENC Encoder",
            options: {
              "nvenc_preset": 1,
              "nvenc_twopass": "quarter_res",
              "nvenc_spatial_aq": "disabled",
              "nvenc_vbv_increase": 0,
              "nvenc_realtime_hags": "enabled",
              "nvenc_latency_over_power": "enabled",
              "nvenc_opengl_vulkan_on_dxgi": "enabled",
              "nvenc_h264_cavlc": "disabled",
            },
          },
          {
            id: "qsv",
            name: "Intel QuickSync Encoder",
            options: {
              "qsv_preset": "medium",
              "qsv_coder": "auto",
              "qsv_slow_hevc": "disabled",
            },
          },
          {
            id: "amd",
            name: "AMD AMF Encoder",
            options: {
              "amd_usage": "ultralowlatency",
              "amd_rc": "vbr_latency",
              "amd_enforce_hrd": "disabled",
              "amd_quality": "balanced",
              "amd_preanalysis": "disabled",
              "amd_vbaq": "enabled",
              "amd_coder": "auto",
            },
          },
          {
            id: "vt",
            name: "VideoToolbox Encoder",
            options: {
              "vt_coder": "auto",
              "vt_software": "auto",
              "vt_realtime": "enabled",
            },
          },
          {
            id: "vaapi",
            name: "VA-API Encoder",
            options: {
              "vaapi_strict_rc_buffer": "disabled",
            },
          },
          {
            id: "sw",
            name: "Software Encoder",
            options: {
              "sw_preset": "superfast",
              "sw_tune": "zerolatency",
            },
          },
        ],
      };
    },
    provide() {
      return {
        platform: computed(() => this.platform)
      }
    },
    created() {
      fetch("./api/config")
        .then((r) => r.json())
        .then((r) => {
          this.config = r;
          this.platform = this.config.platform;

          var app = document.getElementById("app");
          if (this.platform === "windows") {
            this.tabs = this.tabs.filter((el) => {
              return el.id !== "vt" && el.id !== "vaapi";
            });
          }
          if (this.platform === "linux") {
            this.tabs = this.tabs.filter((el) => {
              return el.id !== "amd" && el.id !== "qsv" && el.id !== "vt";
            });
          }
          if (this.platform === "macos") {
            this.tabs = this.tabs.filter((el) => {
              return el.id !== "amd" && el.id !== "nv" && el.id !== "qsv" && el.id !== "vaapi";
            });
          }

          // remove values we don't want in the config file
          delete this.config.platform;
          delete this.config.status;
          delete this.config.version;

          // TODO: let each tab's Component handle it's own data instead of doing it here

          // Parse the special options before population if available
          const specialOptions = ["dd_mode_remapping", "global_prep_cmd"]
          for (const optionKey of specialOptions) {
            if (this.config.hasOwnProperty(optionKey)) {
              this.config[optionKey] = JSON.parse(this.config[optionKey]);
            }
          }

          // Populate default values from tabs options
          this.tabs.forEach(tab => {
            Object.keys(tab.options).forEach(optionKey => {
              if (this.config[optionKey] === undefined) {
                // Make sure to copy by value
                this.config[optionKey] = JSON.parse(JSON.stringify(tab.options[optionKey]));
              }
            });
          });
          // Establish server baseline for diffing and mark initialization complete so autosave can start reacting
          this.serverBaseline = this.serialize();
          this.initialized = true;
        });
    },
    methods: {
      forceUpdate() {
        this.$forceUpdate()
      },
      serialize() {
        return JSON.parse(JSON.stringify(this.config));
      },
      deepCopy(v) { return JSON.parse(JSON.stringify(v)); },
      manualSave() {
        this.save({ includeRestartGated: true });
      },
      onStatusClick() {
        if (!this.restartRequired) return;
        const btn = document.getElementById('restart-apply-button');
        if (btn) {
          btn.scrollIntoView({ behavior: 'smooth', block: 'center' });
          // Give the scroll a moment then focus and highlight
          setTimeout(() => {
            btn.classList.add('pulse-highlight');
            btn.focus({ preventScroll: true });
            setTimeout(() => btn.classList.remove('pulse-highlight'), 2500);
          }, 350);
        }
      },
      scheduleAutoSave() {
        // Only autosave on user-initiated changes to prevent false saves during/after init
        if (!this.userChanged) return;
        // Debounce saves to avoid spamming the backend on rapid input changes
        if (this._autoSaveTimer) {
          clearTimeout(this._autoSaveTimer);
        }
        this._autoSaveTimer = setTimeout(() => {
          this.save({ includeRestartGated: false });
        }, 600);
      },
      save(opts = { includeRestartGated: true }) {
        // Reset UI state and start saving indicator
        this.saved = false;
        this.restarted = false;
        this.appliedNow = false;
        this.deferred = false;
        this.restartRequired = false;
        this.saving = true;

        // create a temp copy of this.config to use for the post request
        let config = this.serialize();

        // delete default values from this.config
        this.tabs.forEach(tab => {
          Object.keys(tab.options).forEach(optionKey => {
            let delete_value = false

            // todo: add proper type checking
            if (JSON.stringify(config[optionKey]) === JSON.stringify(tab.options[optionKey])) {
              delete_value = true
            }

            if (delete_value) {
              delete config[optionKey]
            }
          });
        });

        // If we are autosaving, strip restart-gated dirty keys from payload
        if (!opts.includeRestartGated && this.pendingRestartSave) {
          Object.keys(this.restartGatedDirty).forEach(key => {
            delete config[key];
          });
        }

        const payloadKeys = Object.keys(config);

        // If autosave produced an empty payload (e.g., only restart-gated keys changed),
        // don't make a POST and don't report a transient "saved" state. Instead, stop
        // the spinner and surface that a manual save is needed.
        if (payloadKeys.length === 0) {
          this.saving = false;
          this.appliedNow = false;
          // Recompute pendingRestartSave to ensure indicator reflects unsaved gated changes
          this.restartGatedDirty = {};
          this.restartGatedKeys.forEach(k => {
            const changed = JSON.stringify(this.config[k]) !== JSON.stringify(this.serverBaseline[k]);
            if (changed) this.restartGatedDirty[k] = true;
          });
          this.pendingRestartSave = Object.keys(this.restartGatedDirty).length > 0;
          return Promise.resolve(true);
        }

        return fetch("./api/config", {
          method: "POST",
          headers: {
            'Content-Type': 'application/json'
          },
          body: JSON.stringify(config),
        }).then(async (r) => {
          if (r.status !== 200) {
            this.saving = false;
            return false;
          }
          try {
            const res = await r.json();
            // Flags provided by backend
            this.appliedNow = !!res.appliedNow;
            this.deferred = !!res.deferred;
            this.restartRequired = !!res.restartRequired;
          } catch (e) {
            // Fallback if response isn\'t JSON
          }
          this.saving = false;
          // Clear userChanged latch after a successful save so subsequent
          // programmatic changes won't trigger another save
          this.userChanged = false;

          // Update server baseline for the keys we actually saved
          if (opts.includeRestartGated) {
            // Full save: baseline equals current config
            this.serverBaseline = this.serialize();
          } else {
            // Partial save: update only included keys
            payloadKeys.forEach(k => {
              // Only update keys actually allowed in payload
              if (!(k in this.restartGatedDirty)) {
                this.serverBaseline[k] = this.deepCopy(this.config[k]);
              }
            });
          }
          // Recompute restart-gated dirty set vs baseline
          this.restartGatedDirty = {};
          this.restartGatedKeys.forEach(k => {
            const changed = JSON.stringify(this.config[k]) !== JSON.stringify(this.serverBaseline[k]);
            if (changed) this.restartGatedDirty[k] = true;
          });
          this.pendingRestartSave = Object.keys(this.restartGatedDirty).length > 0;
          return true;
        });
      },
      apply() {
        this.saved = this.restarted = false;
        let saved = this.save();

        saved.then((result) => {
          if (result === true) {
            this.restarted = true;
            setTimeout(() => {
              this.saved = this.restarted = false;
            }, 5000);
            fetch("./api/restart", {
              method: "POST",
              headers: {
                "Content-Type": "application/json"
              }
            });
          }
        });
      },
    },
    watch: {
      // Automatically save whenever any config value changes after initialization
      config: {
        deep: true,
        handler() {
          if (!this.initialized) return;
          // Track restart-gated dirty keys compared to baseline
          this.restartGatedDirty = {};
          this.restartGatedKeys.forEach(k => {
            const changed = JSON.stringify(this.config[k]) !== JSON.stringify(this.serverBaseline[k]);
            if (changed) this.restartGatedDirty[k] = true;
          });
          this.pendingRestartSave = Object.keys(this.restartGatedDirty).length > 0;
          this.scheduleAutoSave();
        }
      }
    },
    mounted() {
      // Mark user-initiated changes when interacting with any inputs on this page
      const onUserInput = () => { this.userChanged = true; };
      const container = document.querySelector('.container');
      if (container) {
        container.addEventListener('input', onUserInput, { passive: true });
        container.addEventListener('change', onUserInput, { passive: true });
      }
      // Handle hashchange events
      const handleHash = () => {
        let hash = window.location.hash;
        if (hash) {
          // remove the # from the hash
          let stripped_hash = hash.substring(1);

          this.tabs.forEach(tab => {
            Object.keys(tab.options).forEach(key => {
              if (tab.id === stripped_hash || key === stripped_hash) {
                this.currentTab = tab.id;
              }
              if (key === stripped_hash) {
                // sleep for 2 seconds to allow the page to load
                setTimeout(() => {
                  let element = document.getElementById(stripped_hash);
                  if (element) {
                    window.location.hash = hash;
                  }
                }, 2000);
              }

              if (this.currentTab === tab.id) {
                // stop looping
                return true;
              }
            });
          });
        }
      };

      // Call handleHash for the initial load
      handleHash();

      // Add hashchange event listener
      window.addEventListener("hashchange", handleHash);
    },
    computed: {
      statusClass() {
  if (this.saving) return 'status-saving';
  // Any pending restart-gated changes or explicit restart requirement should override success
  if (this.restartRequired) return 'status-deferred';
  if (this.pendingRestartSave) return 'status-deferred';
  if (this.appliedNow) return 'status-applied';
  if (this.deferred) return 'status-deferred';
  return 'status-waiting';
      },
      statusText() {
  if (this.saving) return this.$t('config.saving');
  // Show manual save or restart-needed before any transient success message
  if (this.restartRequired) return this.$t('config.restart_required');
  if (this.pendingRestartSave && !this.saving) return this.$t('config.manual_save_needed');
  if (this.appliedNow) return this.$t('config.saved_success');
  if (this.deferred) return this.$t('config.saved_deferred');
  return this.$t('config.waiting_for_changes');
      }
    }
  });

  initApp(app);
</script>