<!DOCTYPE html>
<html lang="en" data-bs-theme="auto">

<head>
  <%- header %>
    <style>
      .config-page {
        padding: 1em;
        border: 1px solid #dee2e6;
        border-top: none;
      }

      .buttons {
        padding: 1em 0;
      }

      /* Sticky config header with save-status dot */
      .config-sticky-header {
        position: sticky;
        top: 0;
        z-index: 1020;
        /* above content, below navbar if fixed */
        background: var(--bs-body-bg);
        padding-top: .5rem;
        padding-bottom: .5rem;
      }

      .config-sticky-header .header-row {
        display: flex;
        justify-content: space-between;
        align-items: center;
      }

      .config-sticky-header h1 {
        margin-bottom: 0;
      }

      .status-area {
        display: flex;
        align-items: center;
        gap: .5rem;
      }

      .status-area.clickable {
        cursor: pointer;
      }

      .status-area.clickable .status-text {
        text-decoration: underline;
        text-underline-offset: 2px;
      }
  .status-actions { display:flex; align-items:center; gap:.5rem; }

      .save-status {
        display: inline-block;
        width: .75rem;
        height: .75rem;
        border-radius: 50%;
        vertical-align: middle;
      }

      .save-status.status-saving {
        background-color: #0d6efd;
        /* bootstrap primary */
        box-shadow: 0 0 0 .25rem rgba(13, 110, 253, .15);
        animation: pulse 1.2s ease-in-out infinite;
      }

      .save-status.status-applied {
        background-color: #198754;
        /* bootstrap success */
      }

      .save-status.status-deferred {
        background-color: #fd7e14;
        /* bootstrap orange */
      }

      .save-status.status-waiting {
        background-color: #6c757d;
        /* bootstrap secondary gray */
        opacity: .85;
      }

      @keyframes pulse {
        0% {
          transform: scale(1);
          opacity: 1;
        }

        50% {
          transform: scale(1.2);
          opacity: .75;
        }

        100% {
          transform: scale(1);
          opacity: 1;
        }
      }

      /* Temporary highlight for restart button when navigated */
      .pulse-highlight {
        animation: btnPulse 1.2s ease-in-out 3;
      }

      @keyframes btnPulse {
        0% {
          box-shadow: 0 0 0 0 rgba(253, 126, 20, .7);
        }

        70% {
          box-shadow: 0 0 0 .6rem rgba(253, 126, 20, 0);
        }

        100% {
          box-shadow: 0 0 0 0 rgba(253, 126, 20, 0);
        }
      }

      /* Search functionality styles */
      .config-search {
        position: relative;
        flex: 1 1 340px;
        max-width: 480px;
        margin: 0 1rem;
      }

      .config-search-results {
        position: absolute;
        top: 100%;
        left: 0;
        right: 0;
        z-index: 1050;
        background: var(--bs-body-bg);
        border: 1px solid var(--bs-border-color);
        border-top: none;
        border-radius: 0 0 .375rem .375rem;
        max-height: 320px;
        overflow-y: auto;
        box-shadow: 0 .125rem .25rem rgba(0, 0, 0, .075);
      }

      .search-result-item {
        padding: .75rem 1rem;
        cursor: pointer;
        border-bottom: 1px solid var(--bs-border-color);
      }

      .search-result-item:last-child {
        border-bottom: none;
      }

      .search-result-item:hover,
      .search-result-item.active {
        background-color: var(--bs-primary-bg-subtle);
        color: var(--bs-emphasis-color);
      }

      .search-result-item.no-results {
        cursor: default;
        color: var(--bs-secondary-color);
        font-style: italic;
      }

      .search-breadcrumb {
        font-weight: 500;
        color: var(--bs-emphasis-color);
      }

      .search-description {
        font-size: .875rem;
        color: var(--bs-secondary-color);
        margin-top: .25rem;
        line-height: 1.3;
      }

      /* Search hit highlight animation */
      .search-hit-pulse {
        animation: searchPulse 2.5s ease-in-out;
      }

      @keyframes searchPulse {
        0% {
          box-shadow: 0 0 0 .25rem rgba(13, 110, 253, .4);
        }
        70% {
          box-shadow: 0 0 0 0 rgba(13, 110, 253, 0);
        }
        100% {
          box-shadow: 0 0 0 0 rgba(13, 110, 253, 0);
        }
      }

      /* Responsive adjustments */
      @media (max-width: 768px) {
        .header-row {
          flex-wrap: wrap;
          gap: .5rem;
        }
        
        .config-search {
          order: 3;
          flex: 1 1 100%;
          margin: .5rem 0 0 0;
          max-width: none;
        }
      }
    </style>
</head>

<body id="app" v-cloak>
  <Navbar></Navbar>
  <div class="container">
    <div class="config-sticky-header">
      <div class="header-row">
        <h1>{{ $t('config.configuration') }}</h1>
        <div class="config-search" v-if="initialized">
          <input 
            type="text" 
            class="form-control" 
            v-model="searchQuery"
            @input="onSearchInput"
            @keydown="onSearchKeydown"
            @focus="searchActive = true"
            @blur="onSearchBlur"
            placeholder="Search settings..."
            aria-label="Search settings"
            role="combobox"
            :aria-expanded="searchActive && searchResults.length > 0"
            :aria-owns="searchActive && searchResults.length > 0 ? 'search-listbox' : null"
            :aria-activedescendant="searchActiveIndex >= 0 ? `search-option-${searchActiveIndex}` : null"
            aria-autocomplete="list"
            ref="searchInput"
          />
          <div 
            v-if="searchActive && searchResults.length > 0" 
            class="config-search-results"
            id="search-listbox"
            role="listbox"
          >
            <div 
              v-for="(result, index) in searchResults" 
              :key="`${result.tabId}-${result.key}`"
              :id="`search-option-${index}`"
              class="search-result-item"
              :class="{ active: index === searchActiveIndex }"
              role="option"
              :aria-selected="index === searchActiveIndex"
              @mousedown.prevent="selectSearchResult(result)"
              @mouseenter="searchActiveIndex = index"
            >
              <div class="search-breadcrumb">{{ result.tabName }} â€º {{ result.labelText }}</div>
              <div v-if="result.descText" class="search-description">{{ result.descText }}</div>
            </div>
          </div>
          <div 
            v-if="searchActive && searchQuery && searchResults.length === 0" 
            class="config-search-results"
          >
            <div class="search-result-item no-results">No matches found</div>
          </div>
        </div>
        <div class="status-actions">
          <div class="status-area" :class="{ clickable: restartRequired }" role="button" :aria-disabled="!restartRequired"
            tabindex="0" @click="onStatusClick" @keydown.enter.prevent="onStatusClick"
            @keydown.space.prevent="onStatusClick">
            <span class="save-status" :class="statusClass"></span>
            <span class="status-text">{{ statusText }}</span>
          </div>
          <button v-if="pendingRestartSave" class="btn btn-sm btn-primary" @click="manualSave">{{ $t('_common.save') }}</button>
        </div>
      </div>
    </div>
    <div class="my-3"></div>
    <div class="form" v-if="config">
      <!-- Header -->
      <ul class="nav nav-tabs">
        <li class="nav-item" v-for="tab in tabs" :key="tab.id">
          <a class="nav-link" :class="{'active': tab.id === currentTab}" href="#"
            @click="currentTab = tab.id">{{tab.name}}</a>
        </li>
      </ul>

      <!-- General Tab -->
      <general v-if="currentTab === 'general'" :config="config" :platform="platform">
      </general>

      <!-- Input Tab -->
      <inputs v-if="currentTab === 'input'" :config="config" :platform="platform">
      </inputs>

      <!-- Audio/Video Tab -->
      <audio-video v-if="currentTab === 'av'" :config="config" :platform="platform">
      </audio-video>

      <!-- Network Tab -->
      <network v-if="currentTab === 'network'" :config="config" :platform="platform">
      </network>

      <!-- Files Tab -->
      <files v-if="currentTab === 'files'" :config="config" :platform="platform">
      </files>

      <!-- Advanced Tab -->
      <advanced v-if="currentTab === 'advanced'" :config="config" :platform="platform">
      </advanced>

      <container-encoders :current-tab="currentTab" :config="config" :platform="platform">
      </container-encoders>
    </div>

    <!-- Bottom banners removed per new UX -->
    <div class="mb-3 buttons">
      <button id="restart-apply-button" class="btn btn-success" @click="apply" v-if="restartRequired && !restarted">{{
        $t('_common.apply') }}</button>
    </div>
  </div>
</body>


<script type="module">
  import { computed, createApp } from 'vue'
  import { initApp } from './init'
  import Navbar from './Navbar.vue'
  import General from './configs/tabs/General.vue'
  import Inputs from './configs/tabs/Inputs.vue'
  import Network from './configs/tabs/Network.vue'
  import Files from './configs/tabs/Files.vue'
  import Advanced from './configs/tabs/Advanced.vue'
  import AudioVideo from './configs/tabs/AudioVideo.vue'
  import ContainerEncoders from './configs/tabs/ContainerEncoders.vue'
  import { $tp, usePlatformI18n } from './platform-i18n'

  const app = createApp({
    components: {
      Navbar,
      General,
      Inputs,
      Network,
      Files,
      Advanced,
      // They will be accessible via audio-video, container-encoders only.
      AudioVideo,
      ContainerEncoders,
    },
    data() {
      return {
        platform: "",
        saved: false,
        restarted: false,
        saving: false,
        appliedNow: false,
        deferred: false,
        restartRequired: false,
        config: null,
        currentTab: "general",
        initialized: false,
        userChanged: false,
        _autoSaveTimer: null,
        _statusClearTimer: null,
        // Autosave gating for restart-required options
        restartGatedKeys: [
          'port', 'address_family', 'origin_web_ui_allowed',
          'capture', 'encoder', 'install_steam_audio_drivers'
        ],
        serverBaseline: {},
        restartGatedDirty: {},
        pendingRestartSave: false,
        // Search functionality
        searchQuery: '',
        searchResults: [],
        searchActiveIndex: -1,
        searchIndex: [],
        searchActive: false,
        searching: false,
        suppressHashHandlerUntil: 0,
        _searchDebounceTimer: null,
        tabs: [ // TODO: Move the options to each Component instead, encapsulate.
          {
            id: "general",
            name: "General",
            options: {
              "locale": "en",
              "sunshine_name": "",
              "min_log_level": 2,
              "global_prep_cmd": [],
              "notify_pre_releases": "disabled",
            },
          },
          {
            id: "input",
            name: "Input",
            options: {
              "controller": "enabled",
              "gamepad": "auto",
              "ds4_back_as_touchpad_click": "enabled",
              "motion_as_ds4": "enabled",
              "touchpad_as_ds4": "enabled",
              "back_button_timeout": -1,
              "keyboard": "enabled",
              "key_repeat_delay": 500,
              "key_repeat_frequency": 24.9,
              "always_send_scancodes": "enabled",
              "key_rightalt_to_key_win": "disabled",
              "mouse": "enabled",
              "high_resolution_scrolling": "enabled",
              "native_pen_touch": "enabled",
              "keybindings": "[0x10,0xA0,0x11,0xA2,0x12,0xA4]",  // todo: add this to UI
            },
          },
          {
            id: "av",
            name: "Audio/Video",
            options: {
              "audio_sink": "",
              "virtual_sink": "",
              "install_steam_audio_drivers": "enabled",
              "adapter_name": "",
              "output_name": "",
              "dd_configuration_option": "disabled",
              "dd_resolution_option": "auto",
              "dd_manual_resolution": "",
              "dd_refresh_rate_option": "auto",
              "dd_manual_refresh_rate": "",
              "dd_hdr_option": "auto",
              "dd_config_revert_delay": 3000,
              "dd_config_revert_on_disconnect": "disabled",
              "dd_mode_remapping": { "mixed": [], "resolution_only": [], "refresh_rate_only": [] },
              "dd_wa_hdr_toggle_delay": 0,
              "max_bitrate": 0,
              "minimum_fps_target": 0
            },
          },
          {
            id: "network",
            name: "Network",
            options: {
              "upnp": "disabled",
              "address_family": "ipv4",
              "port": 47989,
              "origin_web_ui_allowed": "lan",
              "external_ip": "",
              "lan_encryption_mode": 0,
              "wan_encryption_mode": 1,
              "ping_timeout": 10000,
            },
          },
          {
            id: "files",
            name: "Config Files",
            options: {
              "file_apps": "",
              "credentials_file": "",
              "log_path": "",
              "pkey": "",
              "cert": "",
              "file_state": "",
            },
          },
          {
            id: "advanced",
            name: "Advanced",
            options: {
              "fec_percentage": 20,
              "qp": 28,
              "min_threads": 2,
              "hevc_mode": 0,
              "av1_mode": 0,
              "capture": "",
              "encoder": "",
            },
          },
          {
            id: "nv",
            name: "NVIDIA NVENC Encoder",
            options: {
              "nvenc_preset": 1,
              "nvenc_twopass": "quarter_res",
              "nvenc_spatial_aq": "disabled",
              "nvenc_vbv_increase": 0,
              "nvenc_realtime_hags": "enabled",
              "nvenc_latency_over_power": "enabled",
              "nvenc_opengl_vulkan_on_dxgi": "enabled",
              "nvenc_h264_cavlc": "disabled",
            },
          },
          {
            id: "qsv",
            name: "Intel QuickSync Encoder",
            options: {
              "qsv_preset": "medium",
              "qsv_coder": "auto",
              "qsv_slow_hevc": "disabled",
            },
          },
          {
            id: "amd",
            name: "AMD AMF Encoder",
            options: {
              "amd_usage": "ultralowlatency",
              "amd_rc": "vbr_latency",
              "amd_enforce_hrd": "disabled",
              "amd_quality": "balanced",
              "amd_preanalysis": "disabled",
              "amd_vbaq": "enabled",
              "amd_coder": "auto",
            },
          },
          {
            id: "vt",
            name: "VideoToolbox Encoder",
            options: {
              "vt_coder": "auto",
              "vt_software": "auto",
              "vt_realtime": "enabled",
            },
          },
          {
            id: "vaapi",
            name: "VA-API Encoder",
            options: {
              "vaapi_strict_rc_buffer": "disabled",
            },
          },
          {
            id: "sw",
            name: "Software Encoder",
            options: {
              "sw_preset": "superfast",
              "sw_tune": "zerolatency",
            },
          },
        ],
      };
    },
    provide() {
      return {
        platform: computed(() => this.platform)
      }
    },
    created() {
      fetch("./api/config")
        .then((r) => r.json())
        .then((r) => {
          this.config = r;
          this.platform = this.config.platform;

          var app = document.getElementById("app");
          if (this.platform === "windows") {
            this.tabs = this.tabs.filter((el) => {
              return el.id !== "vt" && el.id !== "vaapi";
            });
          }
          if (this.platform === "linux") {
            this.tabs = this.tabs.filter((el) => {
              return el.id !== "amd" && el.id !== "qsv" && el.id !== "vt";
            });
          }
          if (this.platform === "macos") {
            this.tabs = this.tabs.filter((el) => {
              return el.id !== "amd" && el.id !== "nv" && el.id !== "qsv" && el.id !== "vaapi";
            });
          }

          // remove values we don't want in the config file
          delete this.config.platform;
          delete this.config.status;
          delete this.config.version;

          // TODO: let each tab's Component handle it's own data instead of doing it here

          // Parse the special options before population if available
          const specialOptions = ["dd_mode_remapping", "global_prep_cmd"]
          for (const optionKey of specialOptions) {
            if (this.config.hasOwnProperty(optionKey)) {
              this.config[optionKey] = JSON.parse(this.config[optionKey]);
            }
          }

          // Populate default values from tabs options
          this.tabs.forEach(tab => {
            Object.keys(tab.options).forEach(optionKey => {
              if (this.config[optionKey] === undefined) {
                // Make sure to copy by value
                this.config[optionKey] = JSON.parse(JSON.stringify(tab.options[optionKey]));
              }
            });
          });
          // Establish server baseline for diffing and mark initialization complete so autosave can start reacting
          this.serverBaseline = this.serialize();
          this.initialized = true;
          
          // Build search index after configuration and tabs are fully loaded
          this.$nextTick(() => {
            this.buildSearchIndex();
          });
        });
    },
    methods: {
      forceUpdate() {
        this.$forceUpdate()
      },
      serialize() {
        return JSON.parse(JSON.stringify(this.config));
      },
      deepCopy(v) { return JSON.parse(JSON.stringify(v)); },
      manualSave() {
        this.save({ includeRestartGated: true });
      },
      onStatusClick() {
        if (!this.restartRequired) return;
        const btn = document.getElementById('restart-apply-button');
        if (btn) {
          btn.scrollIntoView({ behavior: 'smooth', block: 'center' });
          // Give the scroll a moment then focus and highlight
          setTimeout(() => {
            btn.classList.add('pulse-highlight');
            btn.focus({ preventScroll: true });
            setTimeout(() => btn.classList.remove('pulse-highlight'), 2500);
          }, 350);
        }
      },
      scheduleAutoSave() {
        // Only autosave on user-initiated changes to prevent false saves during/after init
        if (!this.userChanged) return;
        // Debounce saves to avoid spamming the backend on rapid input changes
        if (this._autoSaveTimer) {
          clearTimeout(this._autoSaveTimer);
        }
        this._autoSaveTimer = setTimeout(() => {
          this.save({ includeRestartGated: false });
        }, 600);
      },
      save(opts = { includeRestartGated: true }) {
        // Reset UI state and start saving indicator
        this.saved = false;
        this.restarted = false;
        this.appliedNow = false;
        this.deferred = false;
        this.restartRequired = false;
        this.saving = true;

        // create a temp copy of this.config to use for the post request
        let config = this.serialize();

        // delete default values from this.config
        this.tabs.forEach(tab => {
          Object.keys(tab.options).forEach(optionKey => {
            let delete_value = false

            // todo: add proper type checking
            if (JSON.stringify(config[optionKey]) === JSON.stringify(tab.options[optionKey])) {
              delete_value = true
            }

            if (delete_value) {
              delete config[optionKey]
            }
          });
        });

        // If we are autosaving, strip restart-gated dirty keys from payload
        if (!opts.includeRestartGated && this.pendingRestartSave) {
          Object.keys(this.restartGatedDirty).forEach(key => {
            delete config[key];
          });
        }

        const payloadKeys = Object.keys(config);

        // If autosave produced an empty payload (e.g., only restart-gated keys changed),
        // don't make a POST and don't report a transient "saved" state. Instead, stop
        // the spinner and surface that a manual save is needed.
        if (payloadKeys.length === 0) {
          this.saving = false;
          this.appliedNow = false;
          // Recompute pendingRestartSave to ensure indicator reflects unsaved gated changes
          this.restartGatedDirty = {};
          this.restartGatedKeys.forEach(k => {
            const changed = JSON.stringify(this.config[k]) !== JSON.stringify(this.serverBaseline[k]);
            if (changed) this.restartGatedDirty[k] = true;
          });
          this.pendingRestartSave = Object.keys(this.restartGatedDirty).length > 0;
          return Promise.resolve(true);
        }

        return fetch("./api/config", {
          method: "POST",
          headers: {
            'Content-Type': 'application/json'
          },
          body: JSON.stringify(config),
        }).then(async (r) => {
          if (r.status !== 200) {
            this.saving = false;
            return false;
          }
          try {
            const res = await r.json();
            // Flags provided by backend
            this.appliedNow = !!res.appliedNow;
            this.deferred = !!res.deferred;
            this.restartRequired = !!res.restartRequired;
          } catch (e) {
            // Fallback if response isn\'t JSON
          }
          this.saving = false;
          // Clear userChanged latch after a successful save so subsequent
          // programmatic changes won't trigger another save
          this.userChanged = false;

          // Update server baseline for the keys we actually saved
          if (opts.includeRestartGated) {
            // Full save: baseline equals current config
            this.serverBaseline = this.serialize();
          } else {
            // Partial save: update only included keys
            payloadKeys.forEach(k => {
              // Only update keys actually allowed in payload
              if (!(k in this.restartGatedDirty)) {
                this.serverBaseline[k] = this.deepCopy(this.config[k]);
              }
            });
          }
          // Recompute restart-gated dirty set vs baseline
          this.restartGatedDirty = {};
          this.restartGatedKeys.forEach(k => {
            const changed = JSON.stringify(this.config[k]) !== JSON.stringify(this.serverBaseline[k]);
            if (changed) this.restartGatedDirty[k] = true;
          });
          this.pendingRestartSave = Object.keys(this.restartGatedDirty).length > 0;
          return true;
        });
      },
      apply() {
        this.saved = this.restarted = false;
        let saved = this.save();

        saved.then((result) => {
          if (result === true) {
            this.restarted = true;
            setTimeout(() => {
              this.saved = this.restarted = false;
            }, 5000);
            fetch("./api/restart", {
              method: "POST",
              headers: {
                "Content-Type": "application/json"
              }
            });
          }
        });
      },

      // Search functionality methods
      buildSearchIndex() {
        this.searchIndex = [];
        
        this.tabs.forEach(tab => {
          Object.keys(tab.options).forEach(key => {
            // Get label text - try translation first, fallback to key
            let labelText = '';
            try {
              const translatedLabel = this.$t(`config.${key}`);
              labelText = translatedLabel !== `config.${key}` ? translatedLabel : key;
            } catch (e) {
              labelText = key;
            }

            // Get description text with platform-specific resolution
            let descText = '';
            try {
              // Try platform-specific first
              let descKey = `config.${key}_desc_${this.platform}`;
              let translatedDesc = this.$t(descKey);
              
              if (translatedDesc === descKey) {
                // Fallback to generic description
                descKey = `config.${key}_desc`;
                translatedDesc = this.$t(descKey);
                
                if (translatedDesc !== descKey) {
                  descText = translatedDesc;
                }
              } else {
                descText = translatedDesc;
              }
            } catch (e) {
              // Ignore translation errors
            }

            this.searchIndex.push({
              key,
              tabId: tab.id,
              tabName: tab.name,
              labelText,
              descText,
              rawKey: key
            });
          });
        });
      },

      normalizeText(text) {
        return text.toLowerCase().trim();
      },

      scoreEntry(entry, queryTokens) {
        const searchText = this.normalizeText(`${entry.tabName} ${entry.labelText} ${entry.descText} ${entry.rawKey}`);
        
        // Check if all tokens are present
        const allTokensMatch = queryTokens.every(token => 
          searchText.includes(this.normalizeText(token))
        );
        
        if (!allTokensMatch) return -1;

        let score = 0;
        const normalizedLabel = this.normalizeText(entry.labelText);
        const normalizedRawKey = this.normalizeText(entry.rawKey);
        
        queryTokens.forEach(token => {
          const normalizedToken = this.normalizeText(token);
          
          // Exact prefix match on label or raw key (best score)
          if (normalizedLabel.startsWith(normalizedToken) || normalizedRawKey.startsWith(normalizedToken)) {
            score -= 20;
          }
          // Prefix match on any word in label
          else if (normalizedLabel.split(' ').some(word => word.startsWith(normalizedToken))) {
            score -= 10;
          }
          // Substring match in label
          else if (normalizedLabel.includes(normalizedToken)) {
            score -= 5;
          }
          // Match only in description
          else if (this.normalizeText(entry.descText).includes(normalizedToken)) {
            score -= 1;
          }
        });

        return score;
      },

      onSearchInput() {
        if (this._searchDebounceTimer) {
          clearTimeout(this._searchDebounceTimer);
        }
        
        this._searchDebounceTimer = setTimeout(() => {
          this.performSearch();
        }, 120);
      },

      performSearch() {
        const query = this.searchQuery.trim();
        if (!query) {
          this.searchResults = [];
          this.searchActiveIndex = -1;
          return;
        }

        const tokens = query.split(/\s+/).filter(t => t.length > 0);
        const results = this.searchIndex
          .map(entry => ({
            ...entry,
            score: this.scoreEntry(entry, tokens)
          }))
          .filter(entry => entry.score !== -1)
          .sort((a, b) => {
            if (a.score !== b.score) return a.score - b.score;
            // Tie-break by tab name, then label
            if (a.tabName !== b.tabName) return a.tabName.localeCompare(b.tabName);
            return a.labelText.localeCompare(b.labelText);
          })
          .slice(0, 10);

        this.searchResults = results;
        this.searchActiveIndex = results.length > 0 ? 0 : -1;
      },

      onSearchKeydown(e) {
        if (!this.searchActive || this.searchResults.length === 0) {
          // Handle global shortcuts
          if (e.key === '/' || (e.ctrlKey && e.key === 'k')) {
            e.preventDefault();
            this.$refs.searchInput?.focus();
          }
          return;
        }

        switch (e.key) {
          case 'ArrowDown':
            e.preventDefault();
            this.searchActiveIndex = Math.min(this.searchActiveIndex + 1, this.searchResults.length - 1);
            break;
          case 'ArrowUp':
            e.preventDefault();
            this.searchActiveIndex = Math.max(this.searchActiveIndex - 1, 0);
            break;
          case 'Enter':
            e.preventDefault();
            if (this.searchActiveIndex >= 0 && this.searchResults[this.searchActiveIndex]) {
              this.selectSearchResult(this.searchResults[this.searchActiveIndex]);
            } else if (this.searchResults.length === 1) {
              this.selectSearchResult(this.searchResults[0]);
            }
            break;
          case 'Escape':
            e.preventDefault();
            if (this.searchQuery) {
              this.clearSearch();
            } else {
              this.searchActive = false;
              this.$refs.searchInput?.blur();
            }
            break;
        }
      },

      onSearchBlur() {
        // Delay to allow click events on results
        setTimeout(() => {
          this.searchActive = false;
        }, 150);
      },

      selectSearchResult(entry) {
        // Navigate to tab if different
        if (this.currentTab !== entry.tabId) {
          this.currentTab = entry.tabId;
        }

        // Clear search and close dropdown
        this.clearSearch();
        this.searchActive = false;

        // Set hash suppression to prevent double-scroll
        this.suppressHashHandlerUntil = Date.now() + 1000;

        // Wait for component to mount/update, then scroll and highlight
        this.$nextTick(() => {
          setTimeout(() => {
            const element = document.getElementById(entry.key);
            if (element) {
              // Set hash for consistency
              window.location.hash = '#' + entry.key;
              
              // Scroll into view
              element.scrollIntoView({ behavior: 'smooth', block: 'center' });
              
              // Apply highlight
              this.highlightElement(element);
              
              // Focus first interactive element
              const focusable = element.querySelector('input, select, textarea, button');
              if (focusable) {
                setTimeout(() => {
                  focusable.focus({ preventScroll: true });
                }, 500);
              }
            } else {
              // Fallback: scroll to tab top
              const tabElement = document.querySelector('.config-page');
              if (tabElement) {
                tabElement.scrollIntoView({ behavior: 'smooth', block: 'start' });
              }
            }
          }, 100);
        });
      },

      highlightElement(element) {
        // Remove any existing highlight
        const existing = document.querySelector('.search-hit-pulse');
        if (existing) {
          existing.classList.remove('search-hit-pulse');
        }

        // Find best container for highlight
        let target = element;
        if (element.tagName === 'INPUT' || element.tagName === 'SELECT' || element.tagName === 'TEXTAREA') {
          // For form controls, highlight the parent container
          target = element.closest('.mb-3, .form-check') || element;
        }

        // Apply highlight
        target.classList.add('search-hit-pulse');
        
        // Remove highlight after animation
        setTimeout(() => {
          target.classList.remove('search-hit-pulse');
        }, 2500);
      },

      clearSearch() {
        this.searchQuery = '';
        this.searchResults = [];
        this.searchActiveIndex = -1;
      }
    },
    watch: {
      // Automatically save whenever any config value changes after initialization
      config: {
        deep: true,
        handler() {
          if (!this.initialized) return;
          // Track restart-gated dirty keys compared to baseline
          this.restartGatedDirty = {};
          this.restartGatedKeys.forEach(k => {
            const changed = JSON.stringify(this.config[k]) !== JSON.stringify(this.serverBaseline[k]);
            if (changed) this.restartGatedDirty[k] = true;
          });
          this.pendingRestartSave = Object.keys(this.restartGatedDirty).length > 0;
          this.scheduleAutoSave();
        }
      },

      // Watch for locale changes to rebuild search index
      'config.locale': {
        handler(newLocale, oldLocale) {
          if (this.initialized && newLocale !== oldLocale) {
            // Rebuild search index after locale change with slight delay to let i18n update
            this.$nextTick(() => {
              setTimeout(() => {
                this.buildSearchIndex();
              }, 200);
            });
          }
        }
      }
    },
    mounted() {
      // Mark user-initiated changes when interacting with any inputs on this page
      const onUserInput = () => { this.userChanged = true; };
      const container = document.querySelector('.container');
      if (container) {
        container.addEventListener('input', onUserInput, { passive: true });
        container.addEventListener('change', onUserInput, { passive: true });
      }
      // Handle hashchange events
      const handleHash = () => {
        // Check if hash handling is suppressed (for search navigation)
        if (this.suppressHashHandlerUntil > Date.now()) {
          return;
        }
        
        let hash = window.location.hash;
        if (hash) {
          // remove the # from the hash
          let stripped_hash = hash.substring(1);

          this.tabs.forEach(tab => {
            Object.keys(tab.options).forEach(key => {
              if (tab.id === stripped_hash || key === stripped_hash) {
                this.currentTab = tab.id;
              }
              if (key === stripped_hash) {
                // sleep for 2 seconds to allow the page to load
                setTimeout(() => {
                  let element = document.getElementById(stripped_hash);
                  if (element) {
                    window.location.hash = hash;
                  }
                }, 2000);
              }

              if (this.currentTab === tab.id) {
                // stop looping
                return true;
              }
            });
          });
        }
      };

      // Call handleHash for the initial load
      handleHash();

      // Add hashchange event listener
      window.addEventListener("hashchange", handleHash);
    },
    computed: {
      statusClass() {
  if (this.saving) return 'status-saving';
  // Any pending restart-gated changes or explicit restart requirement should override success
  if (this.restartRequired) return 'status-deferred';
  if (this.pendingRestartSave) return 'status-deferred';
  if (this.appliedNow) return 'status-applied';
  if (this.deferred) return 'status-deferred';
  return 'status-waiting';
      },
      statusText() {
  if (this.saving) return this.$t('config.saving');
  // Show manual save or restart-needed before any transient success message
  if (this.restartRequired) return this.$t('config.restart_required');
  if (this.pendingRestartSave && !this.saving) return this.$t('config.manual_save_needed');
  if (this.appliedNow) return this.$t('config.saved_success');
  if (this.deferred) return this.$t('config.saved_deferred');
  return this.$t('config.waiting_for_changes');
      }
    }
  });

  initApp(app);
</script>